80% of runtime is in 20% of code - focus on this!
				
-- BEFORE STARTING
1) pseudocode 								(design function and class names)
2) IDE 												(gvim vs eclipse)

-- CODING
1) use well tested libraries 	(glib.h)
2) logging library 						(c syslog; c++ Pantheios)
3) documentation/ comments 		(doxygen)

-- COMPILING
1) [compile C using C++ compiler?] 
2) compiler										(gcc/g++, clang)
3) makefile "-Wall -O3 -ansi -pedantic"

-- TESTING & DEBUGGING
1) debugger 									(gdb)
2) unit testing 
3a) static code analysis 			(clang --analyze; unix lint)
3b) code coverage						(gcc-gcov)
4) memory allocation 					(efence; valgrind-memcheck)
 - http://cs.ecs.baylor.edu/~donahoo/tools/valgrind/
5) for parallel programs, trace communication between nodes and thread creation
6) assembly analysis for parallel code
7) double check parallel algorithms 
8) non-threadsafe and race conditions (valgrind helgrind)

-- POST
1) [compare C to C++ assembly?]
2) profiler 		(valgrind: memcheck[heap], callgrind[runtime]; (gcc) gprof[runtime]; google cpu profiler[runtime]; cachegrind[cache])
 - http://valgrind.org/docs/manual/ms-manual.html (memory heap)
 - http://www.cs.utah.edu/dept/old/texinfo/as/gprof.html#SEC1 (runtime)
3) benchmarking
4) remove unecessary debug print lines etc. before presentation
5) fully prepare analysis of data (text output and routines in R?)
6) assembly breakdown: http://www.reddit.com/r/compsci/comments/13n3kh/looking_for_statistics_on_assembly_instruction/
